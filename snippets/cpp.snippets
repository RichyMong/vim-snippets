extends c

## Main
# main()
snippet mainn
	int main()
	{
		${0}
		return 0;
	}
##
## Preprocessor
# #include <...>
snippet incc
	#include <${1:iostream}>
snippet binc
	#include <boost/${1:shared_ptr}.hpp>
##
## STL Collections
# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector
	std::vector<${1:T}> ${2};
# std::deque
snippet deque
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};
# std::list
snippet list
	std::list<${1:T}> ${2};
# std::set
snippet set
	std::set<${1:T}> ${2};
# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	std::stack<${1:T}> ${2};
# std::queue
snippet queue
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};
##
## STL smart pointers
# std::shared_ptr
snippet msp
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
snippet amsp
	auto ${1} = std::make_shared<${2:T}>(${3});
# std::unique_ptr
snippet mup
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
snippet amup
	auto ${1} = std::make_unique<${2:T}>(${3});
##
## Access Modifiers
# private
snippet pri
	private
# protected
snippet pro
	protected
# public
snippet pub
	public
# friend
snippet fr
	friend
# mutable
snippet mu
	mutable
##
## Class
# class
snippet cl
	/*! \class $1
	 *  \brief ${3:Brief class description}
	 *
	 *  ${4:Detailed description}
	 */
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
		$1(${2});
		virtual ~$1();

	protected:
		m_${5}; /*!< ${6:Member description} */
	};
# member function implementation
snippet mfun
	${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
		${0}
	}
# member function implementation without parameters
snippet dmfun0
	/*! \brief ${4:Brief function description here}
	 *
	 *  ${5:Detailed description}
	 *
	 * \return ${6:Return parameter description}
	 */
	${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() {
		${0}
	}
# member function implementation with one parameter
snippet dmfun1
	/*! \brief ${6:Brief function description here}
	 *
	 *  ${7:Detailed description}
	 *
	 * \param $4 ${8:Parameter description}
	 * \return ${9:Return parameter description}
	 */
	${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {
		${0}
	}
# member function implementation with two parameter
snippet dmfun2
	/*! \brief ${8:Brief function description here}
	 *
	 *  ${9:Detailed description}
	 *
	 * \param $4 ${10:Parameter description}
	 * \param $6 ${11:Parameter description}
	 * \return ${12:Return parameter description}
	 */
	${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
		${0}
	}
# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`} {
		${0}
	} /* namespace $1 */
snippet ans
	namespace {
		${0}
	}
##
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} << std::endl;
# std::cin
snippet cin
	std::cin >> ${1};
##
## Casts
# static
snippet sca
	static_cast<${1:unsigned}>(${2:expr})${3}
# dynamic
snippet dca
	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret
snippet rca
	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# const
snippet cca
	const_cast<${1:unsigned}>(${2:expr})${3}
## Iteration
# for i
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# foreach
snippet fore
	for (${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet iter
	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}

# auto iterator
snippet itera
	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld
	[${1}](${2}){
		${3}
	};
# snippets exception
snippet try
	try {

	}catch(${1}) {

	}
# auto function
snippet af auto function
	auto ${1:name}(${2}) -> ${3:void}
	{
		${0}
	};
# Range-v3 transform
snippet transform "ranges::views::transform"
	${1:${2:std::}${3:ranges::}views::}transform($4)
# Range-v3 transform
snippet filter "ranges::views::filter"
	${1:${2:std::}${3:ranges::}views::}filter($4)
# Range-v3 ranges::
snippet r "ranges::"
	ranges::
# Range-v3 ranges::views::
snippet rv "ranges::views::"
	ranges::views::
# Range-v3 ranges::actions::
snippet ra "ranges::actions::"
	ranges::actions::
# STL std::ranges::
snippet sr "std::ranges::"
	std::ranges::
# STL std::views::
snippet sv "std::views::"
	std::views::
##
## Tests
# GTest:add main
snippet gtemain "GTest:add main"
	int main(int argc, char **argv) {
		testing::InitGoogleTest(&argc, argv);
		return RUN_ALL_TESTS();
	}
# GTest:add test
snippet gtetest "GTest:add test"
	TEST(${1:SuiteName}, ${2:TestName}) {
		${0}
	}
# GTest:add fixture
snippet gtefix "GTest:add fixture"
	TEST_F(${1:SuiteName}, ${2:TestName}) {
		${0}
	}
# GTest:add parameterized test
snippet gtepar "GTest:add parameterized test"
	TEST_P(${1:SuiteName}, ${2:TestName}) {
		${0}
	}
# GTest:instantiate parameterized test
snippet gteparins "GTest:instantiate parameterized test"
	INSTANTIATE_TEST_SUITE_P(${1:InstantiationName}, ${2:SuiteName}, ${0});

# Here start ououmania's snippets
snippet incr
	#include "${1:iostream}"

snippet autofr auto function with return value
	auto ${1:name}(${2:args}) -> ${3:void}
	{
		${4:// statement}
	};
snippet ifnot
	if (!${1:expr})
	{
		${2:// statement}
	}
snippet ifnonnull
	if (${1:name} != nullptr)
	{
		${2:// statement}
	}
snippet ifnull
	if (${1:name} == nullptr)
	{
		${2:// statement}
	}

snippet ifempty
	if (${1:name}.empty())
	{
		${2:// statement}
	}
snippet ifnonempty
	if (!${1:name}.empty())
	{
		// ${2:statement}
	}
snippet iflikely
	if (likely(${1:expr}))
	{
		${2:statement}
	}

snippet ifunlikey
	if (unlikely(${1:expr}))
	{
		${2:statement}
	}

snippet clv
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
		$1(${2});
		~$1();

	private:
		${3} ${4}_;
	};

snippet cls_noncopyable
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
		$1(${2});
		~$1();

		$1(const $1 &) = delete;
		$1& operator=(const $1 &) = delete;

	private:
		${3} ${4}_;
	};

# const getter
snippet constg
	const ${1:T} ${2:name}() const { return ${3:member}; }

# nonconst getter
snippet mutableg
	${1:T} ${2:name}()
	{
		return const_cast<$1>(
			const_cast<const ${3:cls}*>(this)->$2());
	}

# r for reference, v for value, s for set, g for get
snippet memvs
	void set_${1:name}(${2:type} v) { $1_ = v; }

snippet memvg
	${1:T} ${2:name}() const { return $2_; }

snippet memvsg
	${1:T} ${2:name}() const { return $2_; }
	void set_$2($1 v) { $2_ = v; }

snippet memrs
	void set_${1:name}(const ${2:type} &v) { $1_ = v; }

snippet memrg
	const ${1:type}& ${2:name}() const { return $2_; }

snippet memrsg
	const ${1:T}& ${2:name}() const { return $2_; }
	void set_$1(const $2 &v) { $1_ = v; }

# mem const getter modifier reference
snippet memcgmr
	const ${1:type}& ${2:name}() const { return $2_; }
	$1& $2()
	{
		return const_cast<$1&>(
			const_cast<const ${3:cls} *>(this)->$2();
	}
# mem const getter modifier pointer
snippet memcgmp
	const ${1:type}* ${2:name}() const { return $2_; }
	$1* $2()
	{
		return const_cast<$1*>(
			const_cast<const ${3:cls} *>(this)->$2();
	}
# name conventions: c for const, v for value, r for reference
snippet autov
	auto ${1:name} = ${2:expr};

snippet cautov
	const auto ${1:name} = ${2:expr};

snippet autor
	auto &${1:name} = ${2:expr};

snippet cautor
	auto &${1:name} = ${2:expr};

snippet iffl
	ret = ${1:func}(${2:args});
	if (ret != 0)
	{
		error_tlog("$1 failed, ret=%d", ret);
	}

snippet iffls
	ret = ${1:func}(${2:args});
	if (ret != 0)
	{
		error_tlog("$1 failed, ret=%s", MTErrorDefine_Name(ret).c_str());
	}

snippet iflg
	if (ret != 0)
	{
		error_tlog("${1:func} failed, ret=%d", ret);
	}

snippet iflgs
	if (ret != 0)
	{
		error_tlog("${1:func} failed, ret=%s", MTErrorDefine_Name(ret).c_str());
	}

snippet ifdfl
	s32 ret = ${1:func}(${2:args});
	if (ret != 0)
	{
		error_tlog("$1 failed, ret=%d", ret);
	}

snippet ifp
	if (${1:name})
	{
		error_tlog("invalid args");
		return E_WX_ERROR_INVALID_PARA;
	}

snippet ifit
	if (${1:it} == ${2:container}.end())
	{
		${3://body}
	}

snippet ifait
	auto ${1:it} = ${2:container}.find(${3:key});
	if ($1 == $2.end())
	{
		error_tlog("${4:%u} not found", $3);
	}

snippet enumt
	enum ${1:name}
	{
		${0}
	};

snippet enumc
	enum class ${1:name} : int {
		${0}
	};

snippet error_invalid_arg
	error_tlog("invalid args");
	return E_WX_ERROR_INVALID_PARA;
snippet error_resource_not_exist
	const auto *${1:res_ptr} = ResMgrInst.Get${2:ResFunc}(${3:id});
	if ($1 == nullptr)
	{
		error_tlog("Get$2<${4:%u}> failed", $3);
		return E_WX_ERROR_RESOURCE_NOT_EXIST;
	}
snippet fort
	for (s32 ${2:i} = 0; $2 < ${1:count}; $2${3:++})
	{
		${4}
	}
snippet forat
	for (auto ${1:x} : ${2})
	{
		${3}
	}
snippet forit
	for (auto it = ${1:begin}; it != ${2:end}; ++it)
	{
		${3}
	}
snippet foritcontainer
	for (auto it = ${1:c}.begin(); it != $1.end(); ++it)
	{
		${2}
	}
snippet forcav
	for (const auto ${1:x} : ${2})
	{
		${3}
	}

snippet forcar
	for (const auto &${1:x} : ${2})
	{
		${3}
	}
# for (custom)
snippet forrt
	for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})
	{
		${5}
	}
# while
snippet wht
	while (${1:/* condition */})
	{
		${0:${VISUAL}}
	}

# do... while
snippet dot
	do
	{
		${0:${VISUAL}}
	}
	while (${1:/* condition */});

snippet dot0
	do
	{
		${0}
	}
	while (0);

snippet if0
	if (${1:name} == 0)
	{
		${0}
	}

snippet ifn0
	if (${1:name} != 0)
	{
		${0}
	}

snippet ptr_triple
	(${1:name} != nullptr ? {$2:valid-expr} : ${3:null-expr})

snippet ns_google_pb
	namespace google
	{
		namespace protobuf
		{
			class Message;
		} // protobuf
	} // google

snippet opm<
	bool operator<(const {$1:T} &other) const
	{
		${2:return true;}
	}

snippet opm=
	bool operator==(const {$1:T} &other) const
	{
		${2:return false;}
	}

snippet uns
	using namespace ${1:std};

snippet forait
	for (auto ${1:it} = ${2:container}.begin(); $1 != $2.end(); ++$1)
	{
		// statement
	}
# for const auto
snippet forca
	for (const auto ${1:x} : ${2}) {
		${3}
	}
snippet aans
	namespace {
		${0}
	} // annoymous namespace

snippet cae
	${1:type} ${2:var} = ($1) ${3:expr};

# for ACM
snippet cstu32
	const u32 ${1:var} = ${2:0};

snippet csts32
	const s32 ${1:var} = ${2:0};

snippet cstf32
	const f32 ${1:var} = ${2:.0f};

snippet cststr
	const std::string &${1:var} = ${2:expr};

# for auto
snippet fora
	for (auto ${1:x} : ${2}) {
		${3}
	}
