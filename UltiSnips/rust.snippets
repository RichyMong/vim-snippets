#######################################################################
#                            Rust Snippets                            #
#######################################################################

priority -50

snippet fn "fn name(?) -> ? {}"
fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pfn "pub fn name(?) -> ? {}"
pub fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet afn "async fn name(?) -> ? {}"
async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pafn "pub async fn name(?) -> ? {}"
pub async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pri "print!(..)" b
print!("$1"${2/..*/, /}$2);
endsnippet

snippet pln "println!(..)" b
println!("$1"${2/..*/, /}$2);
endsnippet

snippet fmt "format!(..)"
format!("$1"${2/..*/, /}$2);
endsnippet

snippet .it ".iter()" i
.iter()$0
endsnippet

snippet impl "impl struct" b
impl ${1:Type} {
	${0}
}
endsnippet

snippet implt "impl trait for a struct" b
impl$3 ${1:Trait} for ${2:Type}${3:<${4:T}>} {
	${0}
}
endsnippet

# snippets by ououmania
snippet allow-dead-code "add #[allow(dead_code)]" b
#[allow(dead_code)]
endsnippet

snippet generic_func "define a generic function" b
fn ${1:name}<${2:T}>(${3}) ${4} {
}
endsnippet

snippet generic_func_where "define a generic function" b
fn ${1:name}<${2:T}>(${3}) -> ${4}
	where {
}
endsnippet

snippet generic_struct "define a generic struct" b
struct ${1:name}<${2:T}> {
}
endsnippet

snippet implf "impl fmt::Display" b
impl std::fmt::Display for ${1:T} {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(self, f)
    }
}
endsnippet

snippet implst "Implement struct" b
impl ${1:} {
}
endsnippet

snippet impl_from "impl From trait for type" b
impl$4 From<${1:U} for ${3:Type}${4:<${5:T}>} {
	fn from(value: $1) -> Self {
	}
}
endsnippet

snippet impl_into "impl Into trait for type" b
impl$4 Into<${1:U} for ${3:Type}${4:<${5:T}>} {
	fn into(value: $1) -> $1 {
	}
}
endsnippet

snippet impl_trait "impl trait for type" b
impl$4 ${1:Trait} for ${3:Type}${4:<${5:T}>} {
	${0}
}
endsnippet

snippet lazy_cell "LazyCell variable" b
${1:name}: LazyCell<${2:type}> = LazyCell::new(|| ${3:initializer});
endsnippet

snippet lazy_lock "LazyLock variable" b
${1:name}: LazyLock<${2:type}> = LazyLock::new(|| ${3:initializer});
endsnippet

snippet lettp "Tuple declaration" b
let ${0:x} : (${1}, ${2}) = (${3}, ${4});
endsnippet

snippet letmr "Mutable reference" b
let ${0:r} = &mut ${1:v};
endsnippet

snippet letsf "String from" b
let ${0:s} = String::from(${1:"hello world"});
endsnippet

snippet letst "Declare a struct variable" b
let ${0:s} = ${1:Struct} {
	${VISUAL}$2
};
endsnippet

snippet match_all "match with all" b
match ${1} {
	${2} => ${3},
	_ => ${4},
}
endsnippet

snippet match_expr "match with an expression" b
${1} => ${2},
endsnippet

snippet match_block "add a single match block" b
${1} => {
	${2}
}
endsnippet

snippet new_object "new of a type" b
let mut ${1:s} = ${2:T}::new();
endsnippet

snippet pfd "pub field" b
pub ${1:name}: ${2:type},
endsnippet

snippet serde_derive "serde derive" b
#[serde(${1:attr})]
endsnippet

snippet serde_rename_all "serde rename the struct with case" b
#[serde(rename_all = ${1|lowercase,UPPERCASE,PascalCase,camelCase,snake_case,SCREAMING_SNAKE_CASE,kebab-case,SCREAMING-KEBAB-CASE})]
endsnippet

snippet serde_rename "serde rename a field" b
#[serde(rename = "${1:name}")]
endsnippet

snippet serde_flatten "serde field attribute" b
#[serde(flatten)]
endsnippet

snippet serde_skip_serialize_all_none "serde skip serialize all the none fields" b
#[serde_with::skip_serializing_none]
endsnippet

snippet serde_skip_serialize_none_field "serde skip serialize a none field" b
#[serde(skip_serializing_if = "Option::is_none")]
endsnippet

snippet serde_skip_serialize_empty_map "serde skip serialize a empty-map field" b
#[serde(skip_serializing_if = "Map::is_empty")]
endsnippet

snippet setter "Struct field setter" b
fn set_${1:field}(&mut self, $1: ${2:type})i {
	self.$1 = $1;
}
endsnippet

snippet stmem "Struct member declaration" b
	${1:name}: ${2:type},
endsnippet

snippet st_fn "struct method" b
fn ${1:function_name}(&self${2})${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet st_fn_mut "struct mutable self method" b
fn ${1:function_name}(&mut self${2})${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet st_pub_fn "pub struct method" b
pub fn ${1:function_name}(&self${2})${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet st_pub_fn_mut "pub struct mutable self method" b
pub fn ${1:function_name}(&mut self${2})${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet string_from "string from a literal" w
String::from("${2:hello}")
endsnippet

# useless to have an immutable new
snippet string_new "string new" w
let mut ${1:s} = String::new();
endsnippet

snippet strum_enum "define a strum enum" b
#[derive(Clone, Copy, Debug, EnumIter, EnumString, PartialEq, strum_macros::Display)]
#[strum(serialize_all = "${2|lowercase,uppercase,snake_case|}")]
pub enum ${1:EnumType} {
    ${3}
}
endsnippet

# define a function of a trait
snippet trait_fn "add new function to trait" b
fn ${1:name}(${3}) -> ${4};
endsnippet

snippet typedef "Type alias" b
type ${1:a} = ${2:b};
endsnippet

snippet useas "Use one as another" b
use ${1:one} as ${2:another};
endsnippet

snippet usestd "Use std" b
use std::${1};
endsnippet

snippet vec "define a vector" b
let ${1:v} = vec![${2}];
endsnippet

snippet vec_mut "define a mut vector" b
let mut ${1:v} = vec![${2}];
endsnippet

snippet vec_new "define a new vector" b
let mut ${1:v} = Vec::new();
endsnippet

snippet vec_push "push to a vector" b
${1:vec}.push(${2:val});
endsnippet

####################snippets for crates####################
snippet clap_arg_default_value "define a clap argument with default value" b
#[arg(short, long, default_value_t = ${3:value})]
${1:name}: ${2:type},
endsnippet

snippet clap_arg_possible_value "define a clap argument with possible value" b
#[arg(short, long, value_parser = clap::builder::PossibleValuesParser::new(${3}))]
${1:name}: ${2:type},
endsnippet

snippet clap_arg_subcommnad "define a clap subcommand argument" b
#[command(subcommand)]
${1:name}: ${2:type},
endsnippet

snippet clap_enum_subcommand "define a clap subcommand enum" b
#[derive(Debug, Subcommand)]
enum ${1:Commands} {
    ${2:Name}(${3:Type}),
}
endsnippet

snippet clap_enum_value "define a clap value enum" b
#[derive(Clone, Debug, ValueEnum)]
enum ${1:EnumType} {
	${2:Name} = ${3:Value},
}
endsnippet

# vim:ft=snippets:
