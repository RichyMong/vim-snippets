priority -50

extends c

# We want to overwrite everything in parent ft.
priority -49
###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


def camel_case_cls_name_from_file():
	import os
	fields = os.path.splitext(fn)[0].split('_')
	snip.rv = ''.join(x.capitalize() for x in fields)


endglobal

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet ponce "#pragma once include guard"
#pragma once

endsnippet

snippet main
int main(int argc, char *argv[])
{
	${0}
	return 0;
}
endsnippet

snippet forc "general for loop (for)"
for (${6:auto} ${1:i} = ${2:v.begin()}; `!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` ${4:!=} ${3:`!p m = re.search(r'^(?:(.*)(\.|->)begin\(\)|((?:std|boost)::)?begin\((.*)\))$', t[2]); snip.rv = (((m.group(3) if m.group(3) else "") + "end(" + m.group(4) + ")") if m.group(4) else (m.group(1) + m.group(2) + "end()")) if m else ""`}; ${5:++`!p snip.rv = t[1].split(" ")[-1]`}) {
	${VISUAL}$0
}
endsnippet

snippet beginend "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	${1/(\w+).*/$1/} (${2:arguments});
	virtual ~${1/(\w+).*/$1/} ();

private:
	${0:/* data */}
};
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
{
	${VISUAL}$0
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet

snippet nsa "namespace alias"
namespace ${1:alias} = ${2:namespace};
endsnippet

snippet using "using directive/using declaration/type alias"
using ${1:namespace}`!p snip.rv = ' ' if t[1] == 'namespace' else ' = ' if t[1] != '' else ''`${2:name};
endsnippet

snippet readfile "read file (readF)"
std::vector<char> v;
if (FILE *fp = fopen(${1:"filename"}, "r"))
{
	char buf[1024];
	while(size_t len = fread(buf, 1, sizeof(buf), fp))
		v.insert(v.end(), buf, buf + len);
	fclose(fp);
}
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "std::vector (v)"
std::vector<${1:char}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet cla "An entire .h generator" b
#ifndef ${2:`!v substitute(vim_snippets#Filename('$1_H','ClassName'),'.*','\U&\E','')`}
#define $2

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
public:
	$1();
	virtual ~$1();

private:
	$3
};

#endif /* $2 */
endsnippet


snippet fnc "Basic c++ doxygen function template" b
/**
* @brief: ${4:brief}
*
* @param: `!p write_docstring_args(t[3],snip)`
*
* @return: `!p snip.rv = t[1]`
*/
${1:ReturnType} ${2:FunctionName}(${3:param})
{
	${0:FunctionBody}
}
endsnippet

snippet boost_test "Boost test module" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_CASE(${2:TestCaseName})
{
	${0:TestDefinition}
}

endsnippet

snippet boost_suite "Boost test suite module" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_SUITE(${2:SuiteName})

BOOST_AUTO_TEST_CASE(${3:TestCaseName})
{
	${0:TestDefinition}
}

BOOST_AUTO_TEST_SUITE_END()

endsnippet
snippet boost_test_fixture "Boost test module with fixture" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

struct ${2:FixtureName} {
	$2() {}
	virtual ~$2() {}
	/* define members here */
};

BOOST_FIXTURE_TEST_CASE(${3:SuiteName}, $2)
{
	${0:TestDefinition}
}

endsnippet

snippet boost_suite_fixture "Boost test suite with fixture" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

struct ${2:FixtureName} {
	$2() {}
	virtual ~$2() {}
	/* define members here */
};

BOOST_FIXTURE_TEST_SUITE(${3:SuiteName}, $2)

BOOST_AUTO_TEST_CASE(${4:TestCaseName})
{
	${0:TestDefinition}
}

BOOST_AUTO_TEST_SUITE_END()

endsnippet

# Here start ououmania's snippets
snippet incc "include a file absolutely" b
#include <${1:iostream}>
endsnippet

snippet incr "include a file relatively" b
#include "${1:iostream}"
endsnippet

snippet autofr "auto function with return value" b
auto ${1:name}(${2:args}) -> ${3:void}
{
	${4}
};
endsnippet

snippet if_not "simply if! block" b
if (!${1:expr})
{
	${2}
}
endsnippet

snippet if_not_null "simply if != nullptr block" b
if (${1:name} != nullptr)
{
	${2:statement};
}
endsnippet

snippet if_null "simply if == nullptr block" b
if (${1:name} == nullptr)
{
	${2:statement};
}
endsnippet

snippet if_empty "if a container is empty" b
if (${1:name}.empty())
{
	${2:statement};
}
endsnippet

snippet if_not_empty "if a container is not empty" b
if (!${1:name}.empty())
{
	${2:statement};
}
endsnippet

snippet if_likely "if likely" b
if (likely(${1:expr}))
{
	${2:statement};
}
endsnippet

snippet if_unlikey "if unlikely" b
if (unlikely(${1:expr}))
{
	${2:statement};
}
endsnippet

snippet clv
class ${1:`!p camel_case_cls_name_from_file()`}
{
public:
	$1(${2});
	~$1();

private:
	${3} ${4}_;
};
endsnippet

snippet cls_noncopyable_def "A noncopyable class with name as camel case file name" b
class ${1:`!p camel_case_cls_name_from_file()`}
{
public:
	$1(${2});
	~$1();

	$1(const $1 &) = delete;
	$1& operator=(const $1 &) = delete;

private:
	${3} ${4}_;
};
endsnippet

# r for reference, v for value, s for set, g for get
snippet memvs "class member value setter" b
void set_${1:name}(${2:type} v) { $1_ = v; }
endsnippet

snippet memvg "class member value getter" b
${1:T} ${2:name}() const { return $2_; }
endsnippet

snippet memvgs "class member value getter and setter" b
${1:T} ${2:name}() const { return $2_; }
void set_$2($1 v) { $2_ = v; }
endsnippet

snippet memrs "class member reference setter" b
void set_${1:name}(const ${2:type} &v) { $1_ = v; }
endsnippet

snippet memrg "class member reference getter" b
const ${1:type}& ${2:name}() const { return $2_; }
endsnippet

snippet memrgs "class member reference getter and setter" b
const ${1:T}& ${2:name}() const { return $2_; }
void set_$1(const $2 &v) { $1_ = v; }
endsnippet

snippet memrgcm "class member const and non-const reference getter" b
${1:type}& ${2:name}() { return $2_; }
const ${1:type}& ${2:name}() const { return $2_; }
endsnippet

snippet constrg "member const reference getter declare" b
const ${1:T} ${2:name}() const;
endsnippet

snippet mutablerg "member non-const reference getter" b
${1:T} ${2:name}()
{
	return const_cast<$1>(
		const_cast<const ${3:cls}*>(this)->$2());
}
endsnippet

snippet memcgmr "mem const and non-const reference getter" b
const ${1:type}& ${2:name}() const;
$1& $2()
{
	return const_cast<$1&>(
		const_cast<const ${3:cls} *>(this)->$2();
}
endsnippet

snippet memcgmp "mem const and non-const pointer getter" b
const ${1:type}* ${2:name}() const;
$1* $2()
{
	return const_cast<$1*>(
		const_cast<const ${3:cls} *>(this)->$2();
}
endsnippet

# name conventions: c for const, v for value, r for reference
snippet autov "auto type value definition" b
auto ${1:name} = ${2:expr};
endsnippet

snippet cst_autov "const auto type value definition" b
const auto ${1:name} = ${2:expr};
endsnippet

snippet autor "auto type reference definition" b
auto &${1:name} = ${2:expr};
endsnippet

snippet cst_autor "const auto type reference definition" b
const auto &${1:name} = ${2:expr};
endsnippet

snippet if_it "if not found in container" b
if (${1:it} == ${2:container}.end()) {
	${3://body}
}
endsnippet

snippet if_nf_it "if not found in container" b
auto ${1:it} = ${2:container}.find(${3:key});
if ($1 == $2.end()) {
	${0:${VISUAL}}
}
endsnippet

snippet enumc "enum class definition" b
enum class ${1:name} : ${2:int} {
	${0}
};
endsnippet

snippet error_invalid_arg
error_tlog("invalid args");
return E_WX_ERROR_INVALID_PARA;
endsnippet

snippet error_resource_not_exist
const auto *${1:res_ptr} = ResMgrInst.Get${2:ResFunc}(${3:id});
if ($1 == nullptr)
{
	error_tlog("Get$2=${4:%u} failed", $3);
	return E_WX_ERROR_RESOURCE_NOT_EXIST;
}
endsnippet

# for (custom)
snippet forrt "for loop index" b
for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {
	${5}
}
endsnippet

snippet do_while "do while" b
do {
	${0:${VISUAL}}
} while (${1:/* condition */});
endsnippet

snippet if0 "if == 0" b
if (${1:name} == 0) {
	${0}
}
endsnippet

snippet ifn0 "if != 0" b
if (${1:name} != 0) {
	${0}
}
endsnippet

snippet ptr_triple "use triple operator to check if an pointer is null"
(${1:name} != nullptr ? {$2:valid-expr} : ${3:null-expr})
endsnippet

snippet ns_google_pb "google protobuf Message forward declaration" b
namespace google
{
	namespace protobuf
	{
		class Message;
	} // protobuf
} // google
endsnippet

snippet pbmsg_forward_decl "google protobuf Message forward declaration" b
namespace google {
namespace protobuf {
class Message;
} // protobuf
} // google
endsnippet

snippet pb_rep_forward_decl "protobuf RepeatedField forward declaration" b
namespace google
{
namespace protobuf
{
template <class T> class RepeatedField;
} // protobuf
} // google
endsnippet

snippet pb_repfield_def "protobuf RepeatedField definition"
google::protobuf::RepeatedField<${1:T}> &${2:var}${3:;}
endsnippet

snippet pb_repptr_forward_decl "protobuf RepeatedField forward declaration" b
namespace google
{
namespace protobuf
{
template <class T> class RepeatedPtrField;
} // protobuf
} // google
endsnippet

snippet pb_repptr_def "protobuf RepeatedPtrField definition"
google::protobuf::RepeatedPtrField<${1:T}> &${2:var}${3:;}
endsnippet

snippet opm< "operator <" b
bool operator<(const {$1:T} &other) const
{
	${2:return true;}
}
endsnippet

snippet opm= "operator ==" b
bool operator==(const {$1:T} &other) const
{
	${2:return false;}
}
endsnippet

snippet uns "using namespace" b
using namespace ${1:std};
endsnippet

snippet forait "for auto iterator" b
for (auto ${1:it} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
	${0}
}
endsnippet

snippet forerase "for auto iterator to erase" b
for (auto ${1:it} = ${2:container}.begin(); $1 != $2.end(); ) {
	if (${3:expr}) {
		it = $2.erase(it);
	} else {
		++it;
	}
}
endsnippet

snippet aans "an anonymous namespace" b
namespace {
${0}
} // annoymous namespace
endsnippet

snippet c_cast "c style cast" b
${1:type} ${2:var} = ($1) ${3:expr};
endsnippet

snippet cst_int "const int value" b
const int ${1:var} = ${2:0};
endsnippet

snippet cst_str "const std::string reference" b
const std::string &${1:var} = ${2:expr};
endsnippet

snippet for_rav "for range loop auto value" b
for (auto ${1:x} : ${2}) {
	${3}
}
endsnippet

snippet for_rcav "for range loop const auto value" b
for (const auto ${1:x} : ${2}) {
	${3}
}
endsnippet

snippet for_rar "for range loop auto reference" b
for (auto &${1:x} : ${2}) {
	${3}
}
endsnippet

snippet for_rcar "for range loop const auto reference" b
for (const auto &${1:x} : ${2}) {
	${3}
}
endsnippet

snippet std_alg_container "call algorithm on a container's begin & end" b
auto ${4:result} = std::{1:algorithm}(${2:vec}.begin(), $2.end(), [](const auto &x) { ${3:block}; });
endsnippet

snippet findv "find in std::vector" b
auto it = std::find(${1:vec}.begin(), $1.end(), ${2:var});
endsnippet

snippet copy "copy to an iterator" b
auto it = std::copy(${1:vec}.begin(), $1.end(), ${2:var});
endsnippet

snippet copyb "copy to an backinserter iterator" b
auto it = std::copy(${1:vec}.begin(), $1.end(), std::back_inserter(${2:var}));
endsnippet

snippet cls_construct "Class constructor" b
${1:`!p camel_case_cls_name_from_file()`}::${1/(\w+).*/$1/}($2)
{
}
endsnippet

snippet cls_desctruct "Class destructor" b
${1:`!p camel_case_cls_name_from_file()`}::~${1/(\w+).*/$1/}()
{
}
endsnippet

snippet cls_mfun "Class member function definition" b
${1:ReturnType} ${2:`!p camel_case_cls_name_from_file()`}::${3:FunctionName}(${4:param})
{
	${5:FunctionBody}
}
endsnippet

snippet cls_noncopyable "a noncopyable class definition" b
${1:`!p camel_case_cls_name_from_file()`}(const $1 &) = delete;
$1& operator=(const $1 &) = delete;
endsnippet

# for ACM
snippet cst_u32 "const u32 value" b
const uint32_t ${1:var} = ${2:0};
endsnippet

snippet cst_f32 "const u32 value" b
const float ${1:var} = ${2:.0f};
endsnippet

snippet cst_u64 "const u64 value" b
const uint64_t ${1:var} = ${2:0};
endsnippet

snippet cst_i64 "const i64 value" b
const int64_t ${1:var} = ${2:0};
endsnippet

snippet if_func_err_log "function call and write error log" b
ret = ${1:func}(${2:args});
if (ret != 0)
{
	error_tlog("`!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` failed, ret=%d", ret);
}
endsnippet

snippet if_func_err_code "function call and write error log with error define string" b
ret = ${1:func}(${2:args});
if (ret != 0)
{
	error_tlog("`!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` failed, ret=%s", MTErrorDefine_Name(ret).c_str());
}
endsnippet

snippet if_err_log "if ret != 0 then error_tlog" b
if (ret != 0)
{
	error_tlog("`!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` failed, ret=%d", ret);
}
endsnippet

snippet if_def_ret_log "define ret as function call result and then check error_tlog" b
int ret = ${1:func}(${2:args});
if (ret != 0)
{
	error_tlog("`!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` failed, ret=%d", ret);
}
endsnippet

snippet if_invalid_arg "check arguments and return invalid arg" b
if (${1:name})
{
	error_tlog("invalid args");
	return E_WX_ERROR_INVALID_PARA;
}
endsnippet

snippet cls_noncopyable_def "a noncopyable class definition" b
class ${1:`!p camel_case_cls_name_from_file()`}
{
public:
	$1(${2});
	~$1();

	$1(const $1 &) = delete;
	$1& operator=(const $1 &) = delete;

private:
	${3} ${4}_;
};
endsnippet

# const getter
snippet constg
	const ${1:T} ${2:name}() const { return ${3:member}; }
endsnippet

snippet do_while_0 "do while 0" b
	do
	{
		${0}
	}
	while (0);
endsnippet

snippet if0 "if equal 0" b
	if (${1:name} == 0)
	{
		${0}
	}
endsnippet

snippet ifn0 "if not equal 0" b
	if (${1:name} != 0)
	{
		${0}
	}
endsnippet

snippet end_triple
	${1:name} == ${2:container}.end() ? {$2:valid-expr} : ${3:end-expr};
endsnippet

snippet ptr_triple
	(${1:name} != nullptr ? {$2:valid-expr} : ${3:null-expr});
endsnippet

snippet opm< "operator < than definition" b
bool operator<(const {$1:T} &other) const
{
	${2:return true;}
}
endsnippet

snippet opm= "operator == than definition" b
bool operator==(const {$1:T} &other) const
{
	${2:return false;}
}
endsnippet

snippet uns "using namespace" b
	using namespace ${1:std};
endsnippet

# vim:ft=snippets:
